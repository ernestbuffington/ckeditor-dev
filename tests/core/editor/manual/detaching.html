<style>
	form ul {
		list-style: none;
	}
	input[disabled]+label {
		text-decoration: line-through;
	}
</style>

<form id="controls" oninput="updateFormControlsDisableState()">
	<section id="type">
		<h2>Editor type:</h2>
		<ul>
			<li><input type="radio" name="editor" value="classic" checked><label>Classic</label></li>
			<li><input type="radio" name="editor" value="inline"><label>Inline </label></li>
			<li><input type="radio" name="editor" value="divarea"><label>Divarea</label></li>
		</ul>
	</section>
	<section id="element">
		<h2>Editor element:</h2>
		<ul>
			<li><input type="radio" name="element" value="textarea" checked><label>Textarea</label></li>
			<li><input type="radio" name="element" value="div"><label>Div</label></li>
		</ul>
	</section>
	<section id="destroy">
		<h2>Destroy:</h2>
		<ul>
			<li><input type="radio" name="destroy" value="0" checked><label>synchronously</label></li>
			<li><input type="radio" name="destroy" value="1"><label>async with 0 timeout</label></li>
			<li><input type="radio" name="destroy" value="2"><label>before 'loaded' event</label></li>
			<li><input type="radio" name="destroy" value="3"><label>before 'scriptLoader.load' callback called</label></li>
			<li><input type="radio" name="destroy" value="4"><label>before iframe#onload</label></li>
		</ul>
	</section>
	<section>
		<button type="submit" onclick="createDestroyEditor( event )">Create editor</button>
	</section>
</form>

<div id="container"></div>

<script>
	if ( bender.tools.env.mobile ) {
		bender.ignore();
	}

	var detachWhenScriptLoaded = detachingTools.detachWhenScriptLoaded,
		detachBeforeIframeLoad = detachingTools.detachBeforeIframeLoad,
		container = CKEDITOR.document.findOne( '#container' ),
		component, editor;

	updateFormControlsDisableState();

	function createDestroyEditor( event ) {
		event.preventDefault();

		var options = getSelectedInputs(),
			element = options.element,
			config = {};

		component = CKEDITOR.dom.element.createFromHtml(
			'<div class="component">' +
			'<' + element + ' id="editor">Hello world!</' + element + '>' +
			'</div>' );

		container.append( component );

		switch ( options.type ) {
			case 'divarea':
				config.extraPlugins = 'divarea';
			case 'classic':
				editor = CKEDITOR.replace( 'editor', config );
				break;
			case 'inline':
				editor = CKEDITOR.inline( 'editor' );
		}

		switch( options.destroyCase ) {
			case "0":
				detach();
				break;
			case "1":
				setTimeout( detach );
				break;
			case "2":
				editor.once( 'loaded', detach, null, null, -9999 );
				break;
			case "3":
				detachWhenScriptLoaded( detach );
				break;
			case "4":
				detachBeforeIframeLoad( detach, editor );
				break;
		}

		updateButtonDisabledState();
	}

	function detach() {
		component.remove();
		component = null;

		editor.destroy();
		editor = null;
		updateButtonDisabledState();
	}

	function getSelectedInputs() {
		return {
			type: getSelectedInputValue( '#type' ),
			element: getSelectedInputValue( '#element' ),
			destroyCase: getSelectedInputValue( '#destroy' )
		};
	}

	function getSelectedInputValue( parentSelector ) {
		return findOne( parentSelector + ' input:checked' ).getValue();
	}

	function findOne( selector ) {
		return CKEDITOR.document.findOne( selector );
	}

	function updateFormControlsDisableState() {
		var input = findOne( '#destroy input[value="4"]' );

		if ( shouldDisable() ) {
			input.setAttribute( 'disabled' );

			if ( input.$.checked ) {
				input.$.checked = false;
			}
		} else {
			input.removeAttribute( 'disabled' );
		}

		updateButtonDisabledState();

		function shouldDisable() {
			if ( !CKEDITOR.env.gecko && !CKEDITOR.env.ie || CKEDITOR.env.edge ) {
				return true;
			}

			return !findOne( '#type input[value="classic"]' ).$.checked;
		}
	}

	function updateButtonDisabledState() {
		var button = findOne( '#controls button' );

		if ( CKEDITOR.document.find( '#controls input:checked' ).toArray().length < 3 || editor ) {
			button.setAttribute( 'disabled' );
		} else {
			button.removeAttribute( 'disabled' );
		}
	}
</script>
